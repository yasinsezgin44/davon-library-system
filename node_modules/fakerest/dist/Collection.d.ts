import { CollectionItem, Embed, Query } from './types.js';
import { Database } from './Database.ts';

export declare class Collection<T extends CollectionItem = CollectionItem> {
    sequence: number;
    items: T[];
    database: Database | null;
    name: string | null;
    identifierName: string;
    getNewId: () => number | string;
    constructor({ items, identifierName, getNewId, }?: {
        items?: T[];
        identifierName?: string;
        getNewId?: () => number | string;
    });
    /**
     * A Collection may need to access other collections (e.g. for embedding references)
     * This is done through a reference to the parent database.
     */
    setDatabase(database: Database): void;
    setName(name: string): void;
    /**
     * Get a one to many embedder function for a given resource name
     *
     * @example embed posts for an author
     *
     *     authorsCollection._oneToManyEmbedder('posts')
     *
     * @returns Function item => item
     */
    _oneToManyEmbedder(resourceName: string): (item: T) => T;
    /**
     * Get a many to one embedder function for a given resource name
     *
     * @example embed author for a post
     *
     *     postsCollection._manyToOneEmbedder('author')
     *
     * @returns Function item => item
     */
    _manyToOneEmbedder(resourceName: string): (item: T) => T;
    /**
     * @param String[] An array of resource names, e.g. ['books', 'country']
     * @returns Function item => item
     */
    _itemEmbedder(embed: Embed): (item: T) => T;
    getCount(query?: Query): number;
    getAll(query?: Query): T[];
    getIndex(identifier: number | string): number;
    getOne(identifier: number | string, query?: Query): T;
    getNewIdFromSequence(): number;
    addOne(item: T): T;
    updateOne(identifier: number | string, item: T): {} & T;
    removeOne(identifier: number | string): T;
}
