var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var isArray$7 = Array.isArray;
var isArray_1 = isArray$7;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$6 = root$7.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObjectLike$7(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$7;
var baseGetTag$4 = _baseGetTag, isObjectLike$6 = isObjectLike_1;
var symbolTag$3 = "[object Symbol]";
function isSymbol$3(value) {
  return typeof value == "symbol" || isObjectLike$6(value) && baseGetTag$4(value) == symbolTag$3;
}
var isSymbol_1 = isSymbol$3;
var isArray$6 = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$6(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
function isObject$6(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$6;
var baseGetTag$3 = _baseGetTag, isObject$5 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag$3(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$4 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var nativeCreate$4 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var getNative$5 = _getNative, root$5 = _root;
var Map$3 = getNative$5(root$5, "Map");
var _Map = Map$3;
var Hash = _Hash, ListCache$3 = _ListCache, Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$3)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var MapCache$2 = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$2)();
  return memoized;
}
memoize$1.Cache = MapCache$2;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var Symbol$3 = _Symbol, arrayMap = _arrayMap, isArray$5 = isArray_1, isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$5(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var isArray$4 = isArray_1, isKey = _isKey, stringToPath = _stringToPath, toString = toString_1;
function castPath$1(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
var _castPath = castPath$1;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$1(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$1;
var castPath = _castPath, toKey = _toKey;
function baseGet$1(object, path) {
  path = castPath(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$1;
var baseGet = _baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
const get$1 = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var ListCache$1 = _ListCache, Map$1 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$3(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$3.prototype.clear = stackClear;
Stack$3.prototype["delete"] = stackDelete;
Stack$3.prototype.get = stackGet;
Stack$3.prototype.has = stackHas;
Stack$3.prototype.set = stackSet;
var _Stack = Stack$3;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$1 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$1;
var defineProperty = _defineProperty;
function baseAssignValue$2(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
var baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function assignValue$2(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$7.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$1(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$4;
function baseTimes$1(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var baseGetTag$2 = _baseGetTag, isObjectLike$5 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$5(value) && baseGetTag$2(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$4 = isObjectLike_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$4(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$3 = isArray_1, isBuffer$2 = isBufferExports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$6 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$2(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$4(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$4;
var copyObject$3 = _copyObject, keys$3 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$3(source, keys$3(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$3 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$3(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$3;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$2(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$1(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$1;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$1(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$2;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var arrayPush$1 = _arrayPush, getPrototype$1 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush = _arrayPush, isArray$2 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$2 = keys_1;
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$2, getSymbols);
}
var _getAllKeys = getAllKeys$2;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var getNative$3 = _getNative, root$4 = _root;
var DataView$1 = getNative$3(root$4, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$3 = _root;
var Promise$2 = getNative$2(root$3, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$2 = _root;
var Set$1 = getNative$1(root$2, "Set");
var _Set = Set$1;
var getNative = _getNative, root$1 = _root;
var WeakMap$1 = getNative(root$1, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView, Map = _Map, Promise$1 = _Promise, Set = _Set, WeakMap = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var getTag$4 = baseGetTag;
if (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map && getTag$4(new Map()) != mapTag$4 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set && getTag$4(new Set()) != setTag$4 || WeakMap && getTag$4(new WeakMap()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root = _root;
var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$2 = _Symbol;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$2 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$3 = _getTag, isObjectLike$2 = isObjectLike_1;
var mapTag$2 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$2(value) && getTag$3(value) == mapTag$2;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var setTag$2 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == setTag$2;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$2 = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag$1 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$1 = isArray_1, isBuffer$1 = isBufferExports, isMap = isMap_1, isObject$1 = isObject_1, isSet = isSet_1, keys$1 = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$2());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$2 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array2 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$2 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$1 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$1)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var Stack = _Stack, baseIsEqual = _baseIsEqual;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject = isObject_1;
function isStrictComparable$1(value) {
  return value === value && !isObject(value);
}
var _isStrictComparable = isStrictComparable$1;
var isStrictComparable = _isStrictComparable, keys = keys_1;
function getMatchData$1(object) {
  var result = keys(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$1(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$1;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseClone$1 = _baseClone, baseMatches = _baseMatches;
var CLONE_DEEP_FLAG$1 = 1;
function matches(source) {
  return baseMatches(baseClone$1(source, CLONE_DEEP_FLAG$1));
}
var matches_1 = matches;
const matches$1 = /* @__PURE__ */ getDefaultExportFromCjs(matches_1);
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
const cloneDeep$1 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeep_1);
class Collection {
  constructor({
    items = [],
    identifierName = "id",
    getNewId
  } = {}) {
    __publicField(this, "sequence", 0);
    __publicField(this, "items", []);
    __publicField(this, "database", null);
    __publicField(this, "name", null);
    __publicField(this, "identifierName", "id");
    __publicField(this, "getNewId");
    if (!Array.isArray(items)) {
      throw new Error(
        "Can't initialize a Collection with anything else than an array of items"
      );
    }
    this.identifierName = identifierName;
    this.getNewId = getNewId || this.getNewIdFromSequence;
    items.map(this.addOne.bind(this));
  }
  /**
   * A Collection may need to access other collections (e.g. for embedding references)
   * This is done through a reference to the parent database.
   */
  setDatabase(database) {
    this.database = database;
  }
  setName(name) {
    this.name = name;
  }
  /**
   * Get a one to many embedder function for a given resource name
   *
   * @example embed posts for an author
   *
   *     authorsCollection._oneToManyEmbedder('posts')
   *
   * @returns Function item => item
   */
  _oneToManyEmbedder(resourceName) {
    if (this.name == null) {
      throw new Error("Can't embed references without a collection name");
    }
    const singularResourceName = this.name.slice(0, -1);
    const referenceName = `${singularResourceName}_id`;
    return (item) => {
      if (this.database == null) {
        throw new Error("Can't embed references without a database");
      }
      const otherCollection = this.database.collections[resourceName];
      if (!otherCollection)
        throw new Error(
          `Can't embed a non-existing collection ${resourceName}`
        );
      if (Array.isArray(item[resourceName])) {
        item[resourceName] = otherCollection.getAll({
          filter: (i) => item[resourceName].indexOf(
            i[otherCollection.identifierName]
          ) !== -1
        });
      } else {
        item[resourceName] = otherCollection.getAll({
          filter: (i) => i[referenceName] === item[this.identifierName]
        });
      }
      return item;
    };
  }
  /**
   * Get a many to one embedder function for a given resource name
   *
   * @example embed author for a post
   *
   *     postsCollection._manyToOneEmbedder('author')
   *
   * @returns Function item => item
   */
  _manyToOneEmbedder(resourceName) {
    const pluralResourceName = `${resourceName}s`;
    const referenceName = `${resourceName}_id`;
    return (item) => {
      if (this.database == null) {
        throw new Error("Can't embed references without a database");
      }
      const otherCollection = this.database.collections[pluralResourceName];
      if (!otherCollection)
        throw new Error(
          `Can't embed a non-existing collection ${resourceName}`
        );
      try {
        item[resourceName] = otherCollection.getOne(
          item[referenceName]
        );
      } catch (e) {
      }
      return item;
    };
  }
  /**
   * @param String[] An array of resource names, e.g. ['books', 'country']
   * @returns Function item => item
   */
  _itemEmbedder(embed) {
    const resourceNames = Array.isArray(embed) ? embed : [embed];
    const resourceEmbedders = resourceNames.map(
      (resourceName) => resourceName.endsWith("s") ? this._oneToManyEmbedder(resourceName) : this._manyToOneEmbedder(resourceName)
    );
    return (item) => resourceEmbedders.reduce(
      (itemWithEmbeds, embedder) => embedder(itemWithEmbeds),
      item
    );
  }
  getCount(query) {
    return this.getAll(query).length;
  }
  getAll(query) {
    let items = this.items.slice(0);
    if (query) {
      if (query.filter) {
        items = filterItems(items, query.filter);
      }
      if (query.sort) {
        items = sortItems(items, query.sort);
      }
      if (query.range) {
        items = rangeItems(items, query.range);
      }
      items = items.map((item) => Object.assign({}, item));
      if (query.embed && this.database) {
        items = items.map(this._itemEmbedder(query.embed));
      }
    }
    return items;
  }
  getIndex(identifier) {
    return this.items.findIndex(
      // biome-ignore lint/suspicious/noDoubleEquals: we want implicit type coercion
      (item) => item[this.identifierName] == identifier
    );
  }
  getOne(identifier, query) {
    const index = this.getIndex(identifier);
    if (index === -1) {
      throw new Error(`No item with identifier ${identifier}`);
    }
    let item = this.items[index];
    item = Object.assign({}, item);
    if ((query == null ? void 0 : query.embed) && this.database) {
      item = this._itemEmbedder(query.embed)(item);
    }
    return item;
  }
  getNewIdFromSequence() {
    return this.sequence++;
  }
  addOne(item) {
    const clone = cloneDeep$1(item);
    const identifier = clone[this.identifierName];
    if (identifier != null) {
      if (this.getIndex(identifier) !== -1) {
        throw new Error(
          `An item with the identifier ${identifier} already exists`
        );
      }
      if (typeof identifier === "number") {
        this.sequence = Math.max(this.sequence, identifier) + 1;
      }
    } else {
      clone[this.identifierName] = this.getNewId();
    }
    this.items.push(clone);
    return clone;
  }
  updateOne(identifier, item) {
    const index = this.getIndex(identifier);
    if (index === -1) {
      throw new Error(`No item with identifier ${identifier}`);
    }
    for (const key in item) {
      this.items[index][key] = item[key];
    }
    return Object.assign({}, this.items[index]);
  }
  removeOne(identifier) {
    const index = this.getIndex(identifier);
    if (index === -1) {
      throw new Error(`No item with identifier ${identifier}`);
    }
    const item = this.items[index];
    this.items.splice(index, 1);
    if (typeof identifier === "number" && identifier == this.sequence - 1) {
      this.sequence--;
    }
    return item;
  }
}
const every = (array, predicate) => array.reduce((acc, value) => acc && predicate(value), true);
const some = (array, predicate) => array.reduce((acc, value) => acc || predicate(value), false);
const getArrayOfObjectsPaths = (keyParts, item) => keyParts.reduce(
  (acc, key, index) => {
    if (acc != null) {
      return acc;
    }
    const keyToArray = keyParts.slice(0, index + 1).join(".");
    const keyToItem = keyParts.slice(index + 1).join(".");
    const itemValue = get$1(item, keyToArray);
    return Array.isArray(itemValue) && index < keyParts.length - 1 ? [keyToArray, keyToItem] : void 0;
  },
  void 0
);
const getSimpleFilter = (key, value) => {
  if (key.indexOf("_q") !== -1) {
    const realKey = key.replace(/(_q)$/, "");
    const regex = new RegExp(value.toString(), "i");
    return (item) => {
      var _a;
      return ((_a = get$1(item, realKey)) == null ? void 0 : _a.toString().match(regex)) !== null;
    };
  }
  if (key.indexOf("_lte") !== -1) {
    const realKey = key.replace(/(_lte)$/, "");
    return (item) => get$1(item, realKey) <= value;
  }
  if (key.indexOf("_gte") !== -1) {
    const realKey = key.replace(/(_gte)$/, "");
    return (item) => get$1(item, realKey) >= value;
  }
  if (key.indexOf("_lt") !== -1) {
    const realKey = key.replace(/(_lt)$/, "");
    return (item) => get$1(item, realKey) < value;
  }
  if (key.indexOf("_gt") !== -1) {
    const realKey = key.replace(/(_gt)$/, "");
    return (item) => get$1(item, realKey) > value;
  }
  if (key.indexOf("_neq_any") !== -1) {
    const realKey = key.replace(/(_neq_any)$/, "");
    const finalValue = Array.isArray(value) ? value : [value];
    return (item) => finalValue.every((val) => get$1(item, realKey) != val);
  }
  if (key.indexOf("_neq") !== -1) {
    const realKey = key.replace(/(_neq)$/, "");
    return (item) => get$1(item, realKey) != value;
  }
  if (key.indexOf("_eq_any") !== -1) {
    const realKey = key.replace(/(_eq_any)$/, "");
    const finalValue = Array.isArray(value) ? value : [value];
    return (item) => finalValue.some((val) => get$1(item, realKey) == val);
  }
  if (key.indexOf("_eq") !== -1) {
    const realKey = key.replace(/(_eq)$/, "");
    return (item) => get$1(item, realKey) == value;
  }
  if (key.indexOf("_inc_any") !== -1) {
    const realKey = key.replace(/(_inc_any)$/, "");
    const finalValue = Array.isArray(value) ? value : [value];
    return (item) => finalValue.some((val) => {
      const itemValue = get$1(item, realKey);
      if (Array.isArray(itemValue)) {
        return itemValue.includes(val);
      }
      if (typeof itemValue === "string") {
        return itemValue.includes(val);
      }
      return false;
    });
  }
  if (key.indexOf("_inc") !== -1) {
    const realKey = key.replace(/(_inc)$/, "");
    const finalValue = Array.isArray(value) ? value : [value];
    return (item) => finalValue.every((val) => {
      const itemValue = get$1(item, realKey);
      if (Array.isArray(itemValue)) {
        return itemValue.includes(val);
      }
      if (typeof itemValue === "string") {
        return itemValue.includes(val);
      }
      return false;
    });
  }
  if (key.indexOf("_ninc_any") !== -1) {
    const realKey = key.replace(/(_ninc_any)$/, "");
    const finalValue = Array.isArray(value) ? value : [value];
    return (item) => finalValue.every((val) => {
      const itemValue = get$1(item, realKey);
      if (Array.isArray(itemValue)) {
        return !itemValue.includes(val);
      }
      if (typeof itemValue === "string") {
        return !itemValue.includes(val);
      }
      return false;
    });
  }
  if (Array.isArray(value)) {
    return (item) => {
      if (Array.isArray(get$1(item, key))) {
        return every(value, (v) => {
          const itemValue = get$1(item, key);
          if (Array.isArray(itemValue)) {
            return some(itemValue, (itemValue2) => itemValue2 == v);
          }
          return false;
        });
      }
      return value.filter((v) => v == get$1(item, key)).length > 0;
    };
  }
  if (typeof value === "object") {
    return (item) => matches$1(value)(get$1(item, key));
  }
  return (item) => {
    const itemValue = get$1(item, key);
    if (Array.isArray(itemValue) && typeof value === "string") {
      return itemValue.indexOf(value) !== -1;
    }
    if (typeof itemValue === "boolean" && typeof value === "string") {
      return itemValue === (value === "true");
    }
    return itemValue == value;
  };
};
function filterItems(items, filter) {
  if (typeof filter === "function") {
    return items.filter(filter);
  }
  if (filter instanceof Object) {
    const filterFunctions = Object.keys(filter).map((key) => {
      if (key === "q" && typeof filter.q === "string") {
        const regex = buildRegexSearch(filter.q);
        const filterWithQuery = (item) => {
          for (const itemKey in item) {
            const itemValue = item[itemKey];
            if (typeof itemValue === "object") {
              if (filterWithQuery(itemValue)) {
                return true;
              }
            }
            if (itemValue && typeof itemValue === "string" && itemValue.match && itemValue.match(regex) !== null)
              return true;
          }
          return false;
        };
        return filterWithQuery;
      }
      const keyParts = key.split(".");
      const value = filter[key];
      if (keyParts.length > 1) {
        return (item) => {
          const arrayOfObjectsPaths = getArrayOfObjectsPaths(
            keyParts,
            item
          );
          if (arrayOfObjectsPaths) {
            const [arrayPath, valuePath] = arrayOfObjectsPaths;
            const itemValue = get$1(item, arrayPath);
            if (Array.isArray(itemValue)) {
              const filteredArrayItems = filterItems(itemValue, {
                [valuePath]: value
              });
              return filteredArrayItems.length > 0;
            }
            return false;
          }
          return getSimpleFilter(key, value)(item);
        };
      }
      return getSimpleFilter(key, value);
    });
    return items.filter(
      (item) => filterFunctions.reduce(
        (selected, filterFunction) => selected && filterFunction(item),
        true
      )
    );
  }
  throw new Error("Unsupported filter type");
}
function sortItems(items, sort) {
  if (typeof sort === "function") {
    return items.sort(sort);
  }
  if (typeof sort === "string") {
    return items.sort((a, b) => {
      if (a[sort] > b[sort]) {
        return 1;
      }
      if (a[sort] < b[sort]) {
        return -1;
      }
      return 0;
    });
  }
  if (Array.isArray(sort)) {
    const key = sort[0];
    const direction = sort[1].toLowerCase() === "asc" ? 1 : -1;
    return items.sort((a, b) => {
      if (a[key] > b[key]) {
        return direction;
      }
      if (a[key] < b[key]) {
        return -1 * direction;
      }
      return 0;
    });
  }
  throw new Error("Unsupported sort type");
}
function rangeItems(items, range) {
  if (Array.isArray(range)) {
    return items.slice(
      range[0],
      range[1] !== void 0 ? range[1] + 1 : void 0
    );
  }
  throw new Error("Unsupported range type");
}
function buildRegexSearch(input) {
  const trimmedInput = input.trim();
  const escapedInput = trimmedInput.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const words = escapedInput.split(" ");
  const pattern = words.map((word) => `(${word})`).join("|");
  const regex = new RegExp(pattern, "i");
  return regex;
}
class Single {
  constructor(obj) {
    __publicField(this, "obj", null);
    __publicField(this, "database", null);
    __publicField(this, "name", null);
    if (!(obj instanceof Object)) {
      throw new Error(
        "Can't initialize a Single with anything except an object"
      );
    }
    this.obj = cloneDeep$1(obj);
  }
  /**
   * A Single may need to access other collections (e.g. for embedded
   * references) This is done through a reference to the parent database.
   */
  setDatabase(database) {
    this.database = database;
  }
  setName(name) {
    this.name = name;
  }
  // No need to embed Singles, since they are by their nature top-level
  // No need to worry about remote references, (i.e. mysingleton_id=1) since
  // it is by definition a singleton
  _oneToManyEmbedder(resourceName) {
    return (item) => {
      if (this.database == null) {
        throw new Error("Can't embed references without a database");
      }
      const otherCollection = this.database.collections[resourceName];
      if (!otherCollection)
        throw new Error(
          `Can't embed a non-existing collection ${resourceName}`
        );
      item[resourceName] = otherCollection.getAll({
        filter: (i) => item[resourceName].indexOf(
          i[otherCollection.identifierName]
        ) !== -1
      });
      return item;
    };
  }
  _manyToOneEmbedder(resourceName) {
    const pluralResourceName = `${resourceName}s`;
    const referenceName = `${resourceName}_id`;
    return (item) => {
      if (this.database == null) {
        throw new Error("Can't embed references without a database");
      }
      const otherCollection = this.database.collections[pluralResourceName];
      if (!otherCollection)
        throw new Error(
          `Can't embed a non-existing collection ${resourceName}`
        );
      try {
        item[resourceName] = otherCollection.getOne(
          item[referenceName]
        );
      } catch (e) {
      }
      return item;
    };
  }
  _itemEmbedder(embed) {
    const resourceNames = Array.isArray(embed) ? embed : [embed];
    const resourceEmbedders = resourceNames.map(
      (resourceName) => resourceName.endsWith("s") ? this._oneToManyEmbedder(resourceName) : this._manyToOneEmbedder(resourceName)
    );
    return (item) => resourceEmbedders.reduce(
      (itemWithEmbeds, embedder) => embedder(itemWithEmbeds),
      item
    );
  }
  getOnly(query) {
    let item = this.obj;
    if ((query == null ? void 0 : query.embed) && this.database) {
      item = Object.assign({}, item);
      item = this._itemEmbedder(query.embed)(item);
    }
    return item;
  }
  updateOnly(item) {
    if (this.obj == null) {
      throw new Error("Can't update a non-existing object");
    }
    for (const key in item) {
      this.obj[key] = item[key];
    }
    return this.obj;
  }
}
class Database {
  constructor({
    data,
    identifierName = "id",
    getNewId
  } = {}) {
    __publicField(this, "identifierName", "id");
    __publicField(this, "collections", {});
    __publicField(this, "singles", {});
    __publicField(this, "getNewId");
    this.getNewId = getNewId;
    this.identifierName = identifierName;
    if (data) {
      this.init(data);
    }
  }
  /**
   * Shortcut for adding several collections if identifierName is always the same
   */
  init(data) {
    for (const name in data) {
      const value = data[name];
      if (Array.isArray(value)) {
        this.addCollection(
          name,
          new Collection({
            items: value,
            identifierName: this.identifierName,
            getNewId: this.getNewId
          })
        );
      } else {
        this.addSingle(name, new Single(value));
      }
    }
  }
  addCollection(name, collection) {
    this.collections[name] = collection;
    collection.setDatabase(this);
    collection.setName(name);
  }
  getCollection(name) {
    return this.collections[name];
  }
  getCollectionNames() {
    return Object.keys(this.collections);
  }
  addSingle(name, single) {
    this.singles[name] = single;
    single.setDatabase(this);
    single.setName(name);
  }
  getSingle(name) {
    return this.singles[name];
  }
  getSingleNames() {
    return Object.keys(this.singles);
  }
  /**
   * @param {string} name
   * @param {string} params As decoded from the query string, e.g. { sort: "name", filter: {enabled:true}, slice: [10, 20] }
   */
  getCount(name, params) {
    return this.collections[name].getCount(params);
  }
  /**
   * @param {string} name
   * @param {string} params As decoded from the query string, e.g. { sort: "name", filter: {enabled:true}, slice: [10, 20] }
   */
  getAll(name, params) {
    return this.collections[name].getAll(params);
  }
  getOne(name, identifier, params) {
    return this.collections[name].getOne(identifier, params);
  }
  addOne(name, item) {
    if (!Object.prototype.hasOwnProperty.call(this.collections, name)) {
      this.addCollection(
        name,
        new Collection({
          items: [],
          identifierName: this.identifierName,
          getNewId: this.getNewId
        })
      );
    }
    return this.collections[name].addOne(item);
  }
  updateOne(name, identifier, item) {
    return this.collections[name].updateOne(identifier, item);
  }
  removeOne(name, identifier) {
    return this.collections[name].removeOne(identifier);
  }
  getOnly(name, params) {
    return this.singles[name].getOnly();
  }
  updateOnly(name, item) {
    return this.singles[name].updateOnly(item);
  }
}
class SimpleRestServer {
  constructor({
    baseUrl = "",
    defaultQuery = () => ({}),
    database,
    middlewares,
    ...options
  } = {}) {
    __publicField(this, "baseUrl", "");
    __publicField(this, "defaultQuery", () => ({}));
    __publicField(this, "middlewares");
    __publicField(this, "database");
    this.baseUrl = baseUrl;
    this.defaultQuery = defaultQuery;
    this.middlewares = middlewares || [];
    if (database) {
      this.database = database;
    } else {
      this.database = new Database(options);
    }
  }
  /**
   * @param Function ResourceName => object
   */
  setDefaultQuery(query) {
    this.defaultQuery = query;
  }
  getContext(normalizedRequest) {
    var _a, _b;
    for (const name of this.database.getSingleNames()) {
      const matches22 = (_a = normalizedRequest.url) == null ? void 0 : _a.match(
        new RegExp(`^${this.baseUrl}\\/(${name})(\\/?.*)?$`)
      );
      if (!matches22) continue;
      return {
        ...normalizedRequest,
        single: name
      };
    }
    const matches2 = (_b = normalizedRequest.url) == null ? void 0 : _b.match(
      new RegExp(
        `^${this.baseUrl}\\/([^\\/?]+)(\\/(\\w+|\\d+))?(\\?.*)?$`
      )
    );
    if (matches2) {
      const name = matches2[1];
      const params = Object.assign(
        {},
        this.defaultQuery(name),
        normalizedRequest.params
      );
      return {
        ...normalizedRequest,
        collection: name,
        params
      };
    }
    return normalizedRequest;
  }
  async handle(normalizedRequest) {
    const context = this.getContext(normalizedRequest);
    let index = 0;
    const middlewares = [...this.middlewares];
    const next = (context2) => {
      const middleware = middlewares[index++];
      if (middleware) {
        return middleware(context2, next);
      }
      return this.handleRequest(context2);
    };
    try {
      const response = await next(context);
      return response;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      return error;
    }
  }
  handleRequest(context) {
    var _a, _b;
    for (const name2 of this.database.getSingleNames()) {
      const matches22 = (_a = context.url) == null ? void 0 : _a.match(
        new RegExp(`^${this.baseUrl}\\/(${name2})(\\/?.*)?$`)
      );
      if (!matches22) continue;
      if (context.method === "GET") {
        try {
          return {
            status: 200,
            body: this.database.getOnly(name2),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
      if (context.method === "PUT") {
        try {
          if (context.requestBody == null) {
            return {
              status: 400,
              headers: {}
            };
          }
          return {
            status: 200,
            body: this.database.updateOnly(
              name2,
              context.requestBody
            ),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
      if (context.method === "PATCH") {
        try {
          if (context.requestBody == null) {
            return {
              status: 400,
              headers: {}
            };
          }
          return {
            status: 200,
            body: this.database.updateOnly(
              name2,
              context.requestBody
            ),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
    }
    const matches2 = (_b = context.url) == null ? void 0 : _b.match(
      new RegExp(
        `^${this.baseUrl}\\/([^\\/?]+)(\\/(\\w+|\\d+))?(\\?.*)?$`
      )
    );
    if (!matches2) {
      return { status: 404, headers: {} };
    }
    const name = matches2[1];
    const params = Object.assign(
      {},
      this.defaultQuery(name),
      context.params
    );
    if (!matches2[2]) {
      if (context.method === "GET") {
        if (!this.database.getCollection(name)) {
          return { status: 404, headers: {} };
        }
        const count = this.database.getCount(
          name,
          params.filter ? { filter: params.filter } : {}
        );
        if (count > 0) {
          const items = this.database.getAll(name, params);
          const first = params.range ? params.range[0] : 0;
          const last = params.range && params.range.length === 2 ? Math.min(
            items.length - 1 + first,
            params.range[1]
          ) : items.length - 1;
          return {
            status: items.length === count ? 200 : 206,
            body: items,
            headers: {
              "Content-Type": "application/json",
              "Content-Range": `items ${first}-${last}/${count}`
            }
          };
        }
        return {
          status: 200,
          body: [],
          headers: {
            "Content-Type": "application/json",
            "Content-Range": "items */0"
          }
        };
      }
      if (context.method === "POST") {
        if (context.requestBody == null) {
          return {
            status: 400,
            headers: {}
          };
        }
        const newResource = this.database.addOne(
          name,
          context.requestBody
        );
        const newResourceURI = `${this.baseUrl}/${name}/${newResource[this.database.getCollection(name).identifierName]}`;
        return {
          status: 201,
          body: newResource,
          headers: {
            "Content-Type": "application/json",
            Location: newResourceURI
          }
        };
      }
    } else {
      if (!this.database.getCollection(name)) {
        return { status: 404, headers: {} };
      }
      const id = matches2[3];
      if (context.method === "GET") {
        try {
          return {
            status: 200,
            body: this.database.getOne(name, id, params),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
      if (context.method === "PUT") {
        try {
          if (context.requestBody == null) {
            return {
              status: 400,
              headers: {}
            };
          }
          return {
            status: 200,
            body: this.database.updateOne(
              name,
              id,
              context.requestBody
            ),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
      if (context.method === "PATCH") {
        try {
          if (context.requestBody == null) {
            return {
              status: 400,
              headers: {}
            };
          }
          return {
            status: 200,
            body: this.database.updateOne(
              name,
              id,
              context.requestBody
            ),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
      if (context.method === "DELETE") {
        try {
          return {
            status: 200,
            body: this.database.removeOne(name, id),
            headers: {
              "Content-Type": "application/json"
            }
          };
        } catch (error) {
          return {
            status: 404,
            headers: {}
          };
        }
      }
    }
    return {
      status: 404,
      headers: {}
    };
  }
  addMiddleware(middleware) {
    this.middlewares.push(middleware);
  }
  addCollection(name, collection) {
    this.database.addCollection(name, collection);
  }
  getCollection(name) {
    return this.database.getCollection(name);
  }
  getCollectionNames() {
    return this.database.getCollectionNames();
  }
  addSingle(name, single) {
    this.database.addSingle(name, single);
  }
  getSingle(name) {
    return this.database.getSingle(name);
  }
  getSingleNames() {
    return this.database.getSingleNames();
  }
}
function parseQueryString(queryString) {
  if (!queryString) {
    return {};
  }
  const queryObject = {};
  const queryElements = queryString.split("&");
  queryElements.map((queryElement) => {
    if (queryElement.indexOf("=") === -1) {
      queryObject[queryElement] = true;
    } else {
      let [key, value] = queryElement.split("=");
      if (value.indexOf("[") === 0 || value.indexOf("{") === 0) {
        value = JSON.parse(value);
      }
      queryObject[key.trim()] = value;
    }
  });
  return queryObject;
}
class SinonAdapter {
  constructor({
    loggingEnabled = false,
    server,
    ...options
  } = {}) {
    __publicField(this, "loggingEnabled", false);
    __publicField(this, "server");
    this.server = server || new SimpleRestServer(options);
    this.loggingEnabled = loggingEnabled;
  }
  getHandler() {
    return async (request) => {
      request.readyState = 4;
      const normalizedRequest = this.getNormalizedRequest(request);
      const response = await this.server.handle(normalizedRequest);
      this.respond(response, request);
    };
  }
  getNormalizedRequest(request) {
    const req = typeof request === "string" ? new Request(request) : request;
    const queryString = req.url ? decodeURIComponent(req.url.slice(req.url.indexOf("?") + 1)) : "";
    const params = parseQueryString(queryString);
    let requestBody = void 0;
    if (req.requestBody) {
      try {
        requestBody = JSON.parse(
          req.requestBody
        );
      } catch (error) {
      }
    }
    return {
      url: req.url,
      headers: new Headers(request.requestHeaders),
      params,
      requestBody,
      method: req.method
    };
  }
  respond(response, request) {
    const sinonResponse = {
      status: response.status,
      body: response.body ?? "",
      headers: response.headers ?? {}
    };
    if (Array.isArray(sinonResponse.headers)) {
      if (!sinonResponse.headers.find((header) => header.name.toLowerCase() === "content-type")) {
        sinonResponse.headers.push({
          name: "Content-Type",
          value: "application/json"
        });
      }
    } else if (!sinonResponse.headers["Content-Type"]) {
      sinonResponse.headers["Content-Type"] = "application/json";
    }
    request.readyState = 1;
    request.respond(
      sinonResponse.status,
      sinonResponse.headers,
      JSON.stringify(sinonResponse.body)
    );
    this.log(request, sinonResponse);
  }
  log(request, response) {
    if (!this.loggingEnabled) return;
    if (console.group) {
      console.groupCollapsed(request.method, request.url, "(FakeRest)");
      console.group("request");
      console.log(request.method, request.url);
      console.log("headers", request.requestHeaders);
      console.log("body   ", request.requestBody);
      console.groupEnd();
      console.group("response", response.status);
      console.log("headers", response.headers);
      console.log("body   ", response.body);
      console.groupEnd();
      console.groupEnd();
    } else {
      console.log(
        "FakeRest request ",
        request.method,
        request.url,
        "headers",
        request.requestHeaders,
        "body",
        request.requestBody
      );
      console.log(
        "FakeRest response",
        response.status,
        "headers",
        response.headers,
        "body",
        response.body
      );
    }
  }
  toggleLogging() {
    this.loggingEnabled = !this.loggingEnabled;
  }
}
const getSinonHandler = (options) => {
  const server = new SinonAdapter(options);
  return server.getHandler();
};
const Server = SinonAdapter;
class FetchMockAdapter {
  constructor({
    loggingEnabled = false,
    server,
    ...options
  } = {}) {
    __publicField(this, "loggingEnabled", false);
    __publicField(this, "server");
    this.server = server || new SimpleRestServer(options);
    this.loggingEnabled = loggingEnabled;
  }
  getHandler() {
    const handler = async (url, options) => {
      const request = new Request(url, options);
      const normalizedRequest = await this.getNormalizedRequest(request);
      const response = await this.server.handle(normalizedRequest);
      this.log(request, response, normalizedRequest);
      return response;
    };
    return handler;
  }
  async getNormalizedRequest(request) {
    const req = typeof request === "string" ? new Request(request) : request;
    const queryString = req.url ? decodeURIComponent(req.url.slice(req.url.indexOf("?") + 1)) : "";
    const params = parseQueryString(queryString);
    const text = await req.text();
    let requestBody = void 0;
    try {
      requestBody = JSON.parse(text);
    } catch (e) {
    }
    return {
      url: req.url,
      headers: req.headers,
      params,
      requestBody,
      method: req.method
    };
  }
  log(request, response, normalizedRequest) {
    if (!this.loggingEnabled) return;
    if (console.group) {
      console.groupCollapsed(
        normalizedRequest.method,
        normalizedRequest.url,
        "(FakeRest)"
      );
      console.group("request");
      console.log(normalizedRequest.method, normalizedRequest.url);
      console.log("headers", request.headers);
      console.log("body   ", request.requestJson);
      console.groupEnd();
      console.group("response", response.status);
      console.log("headers", response.headers);
      console.log("body   ", response.body);
      console.groupEnd();
      console.groupEnd();
    } else {
      console.log(
        "FakeRest request ",
        normalizedRequest.method,
        normalizedRequest.url,
        "headers",
        request.headers,
        "body",
        request.requestJson
      );
      console.log(
        "FakeRest response",
        response.status,
        "headers",
        response.headers,
        "body",
        response.body
      );
    }
  }
  toggleLogging() {
    this.loggingEnabled = !this.loggingEnabled;
  }
}
const getFetchMockHandler = (options) => {
  const server = new FetchMockAdapter(options);
  return server.getHandler();
};
const FetchServer = FetchMockAdapter;
class MswAdapter {
  constructor({ server, ...options }) {
    __publicField(this, "server");
    this.server = server || new SimpleRestServer(options);
  }
  getHandler() {
    return async ({ request }) => {
      const normalizedRequest = await this.getNormalizedRequest(request);
      const response = await this.server.handle(normalizedRequest);
      return new Response(JSON.stringify(response.body), {
        status: response.status,
        headers: response.headers
      });
    };
  }
  async getNormalizedRequest(request) {
    const url = new URL(request.url);
    const params = Object.fromEntries(
      Array.from(new URLSearchParams(url.search).entries()).map(
        ([key, value]) => [key, JSON.parse(value)]
      )
    );
    let requestBody = void 0;
    try {
      const text = await request.text();
      requestBody = JSON.parse(text);
    } catch (e) {
    }
    return {
      url: request.url,
      headers: request.headers,
      params,
      requestBody,
      method: request.method
    };
  }
}
const getMswHandler = (options) => {
  const server = new MswAdapter(options);
  return server.getHandler();
};
const withDelay = (delayMs) => (context, next) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(next(context));
    }, delayMs);
  });
};
export {
  Collection,
  Database,
  FetchMockAdapter,
  FetchServer,
  MswAdapter,
  Server,
  SimpleRestServer,
  Single,
  SinonAdapter,
  getFetchMockHandler,
  getMswHandler,
  getSinonHandler,
  withDelay
};
//# sourceMappingURL=fakerest.js.map
