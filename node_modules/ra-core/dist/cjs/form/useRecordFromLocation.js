"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRecordFromLocation = exports.useRecordFromLocation = void 0;
var react_1 = require("react");
var query_string_1 = require("query-string");
var react_router_dom_1 = require("react-router-dom");
var isEqual_1 = __importDefault(require("lodash/isEqual"));
/**
 * A hook that returns the record to use to override the values in a form
 * @param options The hook options
 * @param options.searchSource The key in the location search to use as a source for the record. Its content should be a stringified JSON object.
 * @param options.stateSource The key in the location state to use as a source for the record
 * @returns The record to use to override the values in a form
 */
var useRecordFromLocation = function (props) {
    if (props === void 0) { props = {}; }
    var searchSource = props.searchSource, stateSource = props.stateSource;
    var location = (0, react_router_dom_1.useLocation)();
    var _a = (0, react_1.useState)(function () {
        return (0, exports.getRecordFromLocation)(location, {
            stateSource: stateSource,
            searchSource: searchSource,
        });
    }), recordFromLocation = _a[0], setRecordFromLocation = _a[1];
    // To avoid having the form resets when the location changes but the final record is the same
    // This is needed for forms such as TabbedForm or WizardForm that may change the location for their sections
    var previousRecordRef = (0, react_1.useRef)(recordFromLocation);
    (0, react_1.useEffect)(function () {
        var newRecordFromLocation = (0, exports.getRecordFromLocation)(location, {
            stateSource: stateSource,
            searchSource: searchSource,
        });
        if (!(0, isEqual_1.default)(newRecordFromLocation, previousRecordRef.current)) {
            previousRecordRef.current = newRecordFromLocation;
            setRecordFromLocation(newRecordFromLocation);
        }
    }, [location, stateSource, searchSource]);
    return recordFromLocation;
};
exports.useRecordFromLocation = useRecordFromLocation;
/**
 * Get the initial record from the location, whether it comes from the location
 * state or is serialized in the url search part.
 */
var getRecordFromLocation = function (_a, _b) {
    var state = _a.state, search = _a.search;
    var _c = _b === void 0 ? {} : _b, _d = _c.searchSource, searchSource = _d === void 0 ? 'source' : _d, _e = _c.stateSource, stateSource = _e === void 0 ? 'record' : _e;
    if (state && state[stateSource]) {
        return state[stateSource];
    }
    if (search) {
        try {
            var searchParams = (0, query_string_1.parse)(search);
            var source = searchParams[searchSource];
            if (source) {
                if (Array.isArray(source)) {
                    console.error("Failed to parse location ".concat(searchSource, " parameter '").concat(search, "'. To pre-fill some fields in the Create form, pass a stringified ").concat(searchSource, " parameter (e.g. '?").concat(searchSource, "={\"title\":\"foo\"}')"));
                    return null;
                }
                return JSON.parse(source);
            }
        }
        catch (e) {
            console.error("Failed to parse location ".concat(searchSource, " parameter '").concat(search, "'. To pre-fill some fields in the Create form, pass a stringified ").concat(searchSource, " parameter (e.g. '?").concat(searchSource, "={\"title\":\"foo\"}')"));
        }
    }
    return null;
};
exports.getRecordFromLocation = getRecordFromLocation;
//# sourceMappingURL=useRecordFromLocation.js.map