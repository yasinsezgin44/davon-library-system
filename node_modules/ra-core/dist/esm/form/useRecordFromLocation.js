import { useEffect, useRef, useState } from 'react';
import { parse } from 'query-string';
import { useLocation } from 'react-router-dom';
import isEqual from 'lodash/isEqual';
/**
 * A hook that returns the record to use to override the values in a form
 * @param options The hook options
 * @param options.searchSource The key in the location search to use as a source for the record. Its content should be a stringified JSON object.
 * @param options.stateSource The key in the location state to use as a source for the record
 * @returns The record to use to override the values in a form
 */
export var useRecordFromLocation = function (props) {
    if (props === void 0) { props = {}; }
    var searchSource = props.searchSource, stateSource = props.stateSource;
    var location = useLocation();
    var _a = useState(function () {
        return getRecordFromLocation(location, {
            stateSource: stateSource,
            searchSource: searchSource,
        });
    }), recordFromLocation = _a[0], setRecordFromLocation = _a[1];
    // To avoid having the form resets when the location changes but the final record is the same
    // This is needed for forms such as TabbedForm or WizardForm that may change the location for their sections
    var previousRecordRef = useRef(recordFromLocation);
    useEffect(function () {
        var newRecordFromLocation = getRecordFromLocation(location, {
            stateSource: stateSource,
            searchSource: searchSource,
        });
        if (!isEqual(newRecordFromLocation, previousRecordRef.current)) {
            previousRecordRef.current = newRecordFromLocation;
            setRecordFromLocation(newRecordFromLocation);
        }
    }, [location, stateSource, searchSource]);
    return recordFromLocation;
};
/**
 * Get the initial record from the location, whether it comes from the location
 * state or is serialized in the url search part.
 */
export var getRecordFromLocation = function (_a, _b) {
    var state = _a.state, search = _a.search;
    var _c = _b === void 0 ? {} : _b, _d = _c.searchSource, searchSource = _d === void 0 ? 'source' : _d, _e = _c.stateSource, stateSource = _e === void 0 ? 'record' : _e;
    if (state && state[stateSource]) {
        return state[stateSource];
    }
    if (search) {
        try {
            var searchParams = parse(search);
            var source = searchParams[searchSource];
            if (source) {
                if (Array.isArray(source)) {
                    console.error("Failed to parse location ".concat(searchSource, " parameter '").concat(search, "'. To pre-fill some fields in the Create form, pass a stringified ").concat(searchSource, " parameter (e.g. '?").concat(searchSource, "={\"title\":\"foo\"}')"));
                    return null;
                }
                return JSON.parse(source);
            }
        }
        catch (e) {
            console.error("Failed to parse location ".concat(searchSource, " parameter '").concat(search, "'. To pre-fill some fields in the Create form, pass a stringified ").concat(searchSource, " parameter (e.g. '?").concat(searchSource, "={\"title\":\"foo\"}')"));
        }
    }
    return null;
};
//# sourceMappingURL=useRecordFromLocation.js.map